file always starts with:

53 4D 57 5F = SMW_ 
37 00 00 00



seems like they're using inflate to compress and stuff.


config file:


FIRST ten bytes are read:(but appearently only one is read)

76633EEC  C2 14 00 90 FE FF FF FF  Â.þÿÿÿ
76633EF4  00 00 00 00 D4 FF FF FF  ....Ôÿÿÿ
76633EFC  00 00 00 00 FE FF FF FF  ....þÿÿÿ
76633F04  DF F1 65 76 F6 F1 65 76  ßñevöñev


then 	2 bytes  
        2 bytes
		1 byte
		
	
Data.dat
,first read 4 the first 4 bytes: C3 2C 00 00

first the app reads in the first four bytes of every dat-file. 

music/MusicDataList.mdl

in music.dat, at offset 0x035e the single byte 0x45 is read, after that the following byte 0x77 is read.
LH meaning in ogg?


char.png

0222 3c10 is location of output buffer

in file start is 0x01cb6a9e

number of bytes to read is 0xd086



02223C10  9F DB 41 37 3F DC 3A D1  ŸÛA7?Ü:Ñ
02223C18  F7 A9 72 7B CB 2C 04 81  ÷©r{Ë,
02223C20  2D F2 A6 61 A8 A6 74 55  -ò¦a¨¦tU
02223C28  D6 9B 99 03 4D 0F A1 64  Ö›™M¡d
02223C30  0D 89 39 86 7B 42 6E 46  .‰9†{BnF
02223C38  B7 DC 72 7B CD 2C 61 51  ·Ür{Í,aQ
02223C40  A2 EB FB D6 93 AC E7 7D  ¢ëûÖ“¬ç}
02223C48  04 49 C4 89 56 50 D4 FA  IÄ‰VPÔú



a =10
b,11
c,12
d,13


0xA8a0

0x2DFE8

0x33b98


at
0x01EBDFE8                       .
a png is stored in ram memory!




ent2.dat

img/field/cliff_glass.png
img/field/cliff_grass_die.png
img/field/cliff_grass_rev.png



at img.dat file, 

at offset 0x01CC87CA is the file img/logo.png


memory bufffer are allocated with heapalloc to contain the decoded png image. 
this buffer is at address 0x002C0000

then a buffer of size 4 is alloced. 

buffer of encoded data is at:

0x01F8DFE8 




b167c0ea


92


ecx =00 18 f1 80


 PUSH ESI							ignore                       
 MOV ESI,ECX                     	ignore
 DEC DWORD PTR DS:[ESI+9C4]			decrease value of constant. but we can ignore it for now.
 JNZ SHORT SuperMar.0048B510        ignore for now
 CALL SuperMar.0048B420				ignore for now
 MOV EAX,DWORD PTR DS:[ESI+9C8]    	
 MOV ECX,DWORD PTR DS:[EAX]
 ADD EAX,4
 MOV DWORD 	PTR DS:[ESI+9C8],EAX        
 MOV EAX,ECX   eax = ecx;  // ecx contains array value.
 SHR EAX,0B    eax >>= 0x0B;                     
 XOR ECX,EAX   ecx ^= eax;
 MOV EDX,ECX   edx = ecx;
 AND EDX,FF3A58AD  edx &=  0xFF3A58AD;
 SHL EDX,7  edx <<= 7;
 XOR ECX,EDX ecx ^= edx;
 MOV EAX,ECX  eax = ecx;
 AND EAX,FFFFDF8C  eax &= 0xFFFFDF8C;
 SHL EAX,0F  eax <<= 0x0F;
 XOR ECX,EAX  ecx ^= eax;
 MOV EAX,ECX  eax = ecx;
 SHR EAX,12  eax >>= 0x12;
 XOR EAX,ECX  eax ^= ecx;      
 POP ESI   
 RETN
 
 
 
 
 constant at 	esi+9c8 is intially:
 
 84 f1 18 00. this value is constantly increased by four. 
 
 
 00 18 f1 84 is the address
 
 73 23 75 71 is the value
 
 e9 41 2f 29 next value
 
 26f is the size of the array. 
 
 
 5a e9 	e7 cc
 
 
 84 f1 18 00 is the entire address to the array of codes.
 
 
 
 73 23 75 71


the decoding code is at line: 
 00486CF5  |> 8D4C24 18      /LEA ECX,DWORD PTR SS:[ESP+18]           ;  ecx is probly argument to function call. ecx is always asiggned the same value it seems


 at
 esi +9c4 is the counter
 esi +9c8 is the array beginning. 
 
 30 9c db 3e
 f1 4e 8a d8
 7c a7 6e b3
 
initally it contains the array data:(at ) 
 
 
	3E DB 9C 30
 
3EDB9C30
 
0018F184  30 9C DB 3E   F1 4E 8A D8   7C A7 6E B3  B9 82 BC BE  0œÛ>ñNŠØ|§n³¹‚¼¾
0018F194  CB A6 72 99  52 5E FC 40  C5 A1 50 4A   5B B6 BD 94  Ë¦r™R^ü@Å¡PJ[¶½”
0018F1A4  25 92 DD BD   6C 88 B2 EE   D5 3A 7C 46  AF A9 4A 56  %’Ý½lˆ²îÕ:|F¯©JV
0018F1B4  B2 0F 05 0C 47 73 43 F9 E2 DD 27 47 9E 05 AE 3D  ².GsCùâÝ'Gž®=

then it contains 

0018F184  71 75 23 73  29 2F 41 E9  DB 14 AB 3B  CD D2 D7 6B  qu#s)/AéÛ«;ÍÒ×k
0018F194  93 0E 82 E4 17 27 AC 4D 32 EE 68 F2 74 76 60 20  “‚ä'¬M2îhòtv`
0018F1A4  C1 FB 3D 8B 6F FD 13 54 C7 9A C9 B0 9A 57 A9 31  Áû=‹oýTÇšÉ°šW©1
0018F1B4  74 0E BB 7A 00 45 BD 1E 84 45 2A 4E 7D 59 E4 88  t»z.E½„E*N}Yäˆ

then:

0018F184  BD 53 15 DF C1 8B 4F 4F 66 C1 A6 A3 76 C5 5B 7C  ½SßÁ‹OOfÁ¦£vÅ[|
0018F194  41 F9 DB AD 1D AA 09 C5 B2 0F FA 53 E6 15 C3 94  AùÛ­ª.Å²úSæÃ”
0018F1A4  13 B3 C2 7F 2B 7E 5B 24 4B 44 5A 3F B0 C7 BC CB  ³Â+~[$KDZ?°Ç¼Ë
0018F1B4  0C C3 42 DE 6E 01 06 82 2D 5E 99 3F 7D 21 F4 79  .ÃBÞn‚-^™?}!ôy



0018F184  71 10 F2 73 4B 51 FD B3 5B 27 66 68 2E F7 5F F0  qòsKQý³['fh.÷_ð
0018F194  EE 11 DC 82 A7 CC 08 27 BB 5C D5 60 E6 68 86 0A  îÜ‚§Ì'»\Õ`æh†.
0018F1A4  98 72 84 1B 71 81 DD 8B C3 9F 0D 79 61 FC 36 52  ˜r„qÝ‹ÃŸ.yaü6R
0018F1B4  ED A0 92 5F 64 9A AF 08 F1 B2 56 DD 73 0B FB FF  í ’_dš¯ñ²VÝsûÿ




0018F184  AB A8 12 02 00 00 00 00 BC F1 18 00 00 00 23 02  «¨....¼ñ...#
0018F194  00 00 23 03 E0 F0 18 00 00 80 00 00 70 F2 18 00  ..#àð..€..pò.
0018F1A4  F5 71 ED 77 64 72 96 00 FE FF FF FF D3 3C E9 77  õqíwdr–.þÿÿÿÓ<éw
0018F1B4  FE 3C E9 77 40 00 00 00 58 00 00 00 AA A8 12 02  þ<éw@...X...ª¨


img/char.png



3EDB9C30


0048E2E6 



00486CCF



from 0x3EDB9C30 we compute 
 0xD88A4EF1
 
eax = 1
 
 
MOV ESI,DWORD PTR DS:[EDX-8]   // esi is now 0x3EDB9C30
MOV EDI,ESI     edi = esi
SHR EDI,1E      edi >>>= 0x1E
XOR EDI,ESI     edi ^= esi
IMUL EDI,EDI,6C078965  edi *= 0x6C078965
LEA ESI,DWORD PTR DS:[EDI+EAX]      esi = edi+eax 
MOV EDI,ESI  edi = esi     
SHR EDI,1E   edi >>>= 0x1E
XOR EDI,ESI  edi ^= esi
IMUL EDI,EDI,6C078965   edi *= 6C078965
MOV DWORD PTR DS:[EDX-4],ESI   second = esi       







LEA ESI,DWORD PTR DS:[EDI+EAX+6]	esi = edi+eax+6;
MOV DWORD PTR DS:[EDX+14],ESI   	        ;  write! eight value



eax+634




0018F7B8  D6 E2 6E C6 97 7C F6 B0 58 E5 FD FD 77 31 66 BE  ÖânÆ—|ö°Xåýýw1f¾
0018F7C8  BA 21 FC 84 2A C7 8C F1 C0 85 3E 61 B9 0F 86 E7  º!ü„*ÇŒñÀ…>a¹†ç
0018F7D8  F7 BF 64 FC DA 50 25 AE CF 7E E4 02 43 D0 AB 37  ÷¿düÚP%®Ï~äCÐ«7


D6 E2 6E C6 97 7C F6 B0 58 E5 FD FD 77 31 66 BE


 0xB3ECF0A1
 
 
 
 
MOV ECX,DWORD PTR DS:[EAX+4]    ecx = arr[1]
MOV EDI,DWORD PTR DS:[EAX]      edi = arr[0]
MOV EBX,DWORD PTR DS:[EAX]      ebx = arr[0]
XOR EDI,ECX                     edi ^= ecx
AND EDI,7FFFFFFE                edi ^= 0x7FFFFFFE
XOR EDI,EBX                     edi ^= ebx
AND CL,1			            ecx ^= 0xFFFFFF01
SHR EDI,1						edi >>>= 1
NEG CL							ecx = -((byte)(ecx & 0xFF)) & ecx
SBB ECX,ECX                       if cl, was not zero, add an extra one. 
AND ECX,9908B0DF                ecx &= 0x9908B0DF
XOR EDI,ECX                     edi ^= ecx
XOR EDI,DWORD PTR DS:[EAX+634]  edi ^= arr[397]        ;  edi contains the computed dword. wait, is this not simply the same array?
MOV DWORD PTR DS:[EAX],EDI      arr[0] = edi        ;  set a dword in the array.
ADD EAX,4                       iterate further
DEC EDX                         increase i of for loop.
JNZ SHORT SuperMar.0048B440

