file always starts with:

53 4D 57 5F = SMW_ 
37 00 00 00



seems like they're using inflate to compress and stuff.


config file:


FIRST ten bytes are read:(but appearently only one is read)

76633EEC  C2 14 00 90 FE FF FF FF  Â.þÿÿÿ
76633EF4  00 00 00 00 D4 FF FF FF  ....Ôÿÿÿ
76633EFC  00 00 00 00 FE FF FF FF  ....þÿÿÿ
76633F04  DF F1 65 76 F6 F1 65 76  ßñevöñev


then 	2 bytes  
        2 bytes
		1 byte
		
	
Data.dat
,first read 4 the first 4 bytes: C3 2C 00 00

first the app reads in the first four bytes of every dat-file. 

music/MusicDataList.mdl

in music.dat, at offset 0x035e the single byte 0x45 is read, after that the following byte 0x77 is read.
LH meaning in ogg?


char.png

0222 3c10 is location of output buffer

in file start is 0x01cb6a9e

number of bytes to read is 0xd086



02223C10  9F DB 41 37 3F DC 3A D1  ŸÛA7?Ü:Ñ
02223C18  F7 A9 72 7B CB 2C 04 81  ÷©r{Ë,
02223C20  2D F2 A6 61 A8 A6 74 55  -ò¦a¨¦tU
02223C28  D6 9B 99 03 4D 0F A1 64  Ö›™M¡d
02223C30  0D 89 39 86 7B 42 6E 46  .‰9†{BnF
02223C38  B7 DC 72 7B CD 2C 61 51  ·Ür{Í,aQ
02223C40  A2 EB FB D6 93 AC E7 7D  ¢ëûÖ“¬ç}
02223C48  04 49 C4 89 56 50 D4 FA  IÄ‰VPÔú



a =10
b,11
c,12
d,13


0xA8a0

0x2DFE8

0x33b98


at
0x01EBDFE8                       .
a png is stored in ram memory!




ent2.dat

img/field/cliff_glass.png
img/field/cliff_grass_die.png
img/field/cliff_grass_rev.png



at img.dat file, 

at offset 0x01CC87CA is the file img/logo.png


memory bufffer are allocated with heapalloc to contain the decoded png image. 
this buffer is at address 0x002C0000

then a buffer of size 4 is alloced. 

buffer of encoded data is at:

0x01F8DFE8 




b167c0ea


92


ecx =00 18 f1 80


 PUSH ESI							ignore                       
 MOV ESI,ECX                     	ignore
 DEC DWORD PTR DS:[ESI+9C4]			decrease value of constant. but we can ignore it for now.
 JNZ SHORT SuperMar.0048B510        ignore for now
 CALL SuperMar.0048B420				ignore for now
 MOV EAX,DWORD PTR DS:[ESI+9C8]    	
 MOV ECX,DWORD PTR DS:[EAX]
 ADD EAX,4
 MOV DWORD 	PTR DS:[ESI+9C8],EAX        
 MOV EAX,ECX   eax = ecx;  // ecx contains array value.
 SHR EAX,0B    eax >>= 0x0B;                     
 XOR ECX,EAX   ecx ^= eax;
 MOV EDX,ECX   edx = ecx;
 AND EDX,FF3A58AD  edx &=  0xFF3A58AD;
 SHL EDX,7  edx <<= 7;
 XOR ECX,EDX ecx ^= edx;
 MOV EAX,ECX  eax = ecx;
 AND EAX,FFFFDF8C  eax &= 0xFFFFDF8C;
 SHL EAX,0F  eax <<= 0x0F;
 XOR ECX,EAX  ecx ^= eax;
 MOV EAX,ECX  eax = ecx;
 SHR EAX,12  eax >>= 0x12;
 XOR EAX,ECX  eax ^= ecx;      
 POP ESI   
 RETN
 
 
 
 
 constant at 	esi+9c8 is intially:
 
 84 f1 18 00. this value is constantly increased by four. 
 
 
 00 18 f1 84 is the address
 
 73 23 75 71 is the value
 
 e9 41 2f 29 next value
 
 26f is the size of the array. 
 
 
 5a e9 	e7 cc
 
 
 84 f1 18 00 is the entire address to the array of codes.
 
 
 
 73 23 75 71


the decoding code is at line: 
 00486CF5  |> 8D4C24 18      /LEA ECX,DWORD PTR SS:[ESP+18]           ;  ecx is probly argument to function call. ecx is always asiggned the same value it seems


 at
 esi +9c4 is the counter
 esi +9c8 is the array beginning. 
 
 30 9c db 3e
 f1 4e 8a d8
 7c a7 6e b3
 
initally it contains the array data:(at ) 
 
 
	3E DB 9C 30
 
3EDB9C30
 
0018F184  30 9C DB 3E   F1 4E 8A D8   7C A7 6E B3  B9 82 BC BE  0œÛ>ñNŠØ|§n³¹‚¼¾
0018F194  CB A6 72 99  52 5E FC 40  C5 A1 50 4A   5B B6 BD 94  Ë¦r™R^ü@Å¡PJ[¶½”
0018F1A4  25 92 DD BD   6C 88 B2 EE   D5 3A 7C 46  AF A9 4A 56  %’Ý½lˆ²îÕ:|F¯©JV
0018F1B4  B2 0F 05 0C 47 73 43 F9 E2 DD 27 47 9E 05 AE 3D  ².GsCùâÝ'Gž®=

then it contains 

0018F184  71 75 23 73  29 2F 41 E9  DB 14 AB 3B  CD D2 D7 6B  qu#s)/AéÛ«;ÍÒ×k
0018F194  93 0E 82 E4 17 27 AC 4D 32 EE 68 F2 74 76 60 20  “‚ä'¬M2îhòtv`
0018F1A4  C1 FB 3D 8B 6F FD 13 54 C7 9A C9 B0 9A 57 A9 31  Áû=‹oýTÇšÉ°šW©1
0018F1B4  74 0E BB 7A 00 45 BD 1E 84 45 2A 4E 7D 59 E4 88  t»z.E½„E*N}Yäˆ

then:

0018F184  BD 53 15 DF C1 8B 4F 4F 66 C1 A6 A3 76 C5 5B 7C  ½SßÁ‹OOfÁ¦£vÅ[|
0018F194  41 F9 DB AD 1D AA 09 C5 B2 0F FA 53 E6 15 C3 94  AùÛ­ª.Å²úSæÃ”
0018F1A4  13 B3 C2 7F 2B 7E 5B 24 4B 44 5A 3F B0 C7 BC CB  ³Â+~[$KDZ?°Ç¼Ë
0018F1B4  0C C3 42 DE 6E 01 06 82 2D 5E 99 3F 7D 21 F4 79  .ÃBÞn‚-^™?}!ôy



0018F184  71 10 F2 73 4B 51 FD B3 5B 27 66 68 2E F7 5F F0  qòsKQý³['fh.÷_ð
0018F194  EE 11 DC 82 A7 CC 08 27 BB 5C D5 60 E6 68 86 0A  îÜ‚§Ì'»\Õ`æh†.
0018F1A4  98 72 84 1B 71 81 DD 8B C3 9F 0D 79 61 FC 36 52  ˜r„qÝ‹ÃŸ.yaü6R
0018F1B4  ED A0 92 5F 64 9A AF 08 F1 B2 56 DD 73 0B FB FF  í ’_dš¯ñ²VÝsûÿ




0018F184  AB A8 12 02 00 00 00 00 BC F1 18 00 00 00 23 02  «¨....¼ñ...#
0018F194  00 00 23 03 E0 F0 18 00 00 80 00 00 70 F2 18 00  ..#àð..€..pò.
0018F1A4  F5 71 ED 77 64 72 96 00 FE FF FF FF D3 3C E9 77  õqíwdr–.þÿÿÿÓ<éw
0018F1B4  FE 3C E9 77 40 00 00 00 58 00 00 00 AA A8 12 02  þ<éw@...X...ª¨


img/char.png



3EDB9C30


0048E2E6 



00486CCF



from 0x3EDB9C30 we compute 
 0xD88A4EF1
 
eax = 1
 
 
MOV ESI,DWORD PTR DS:[EDX-8]   // esi is now 0x3EDB9C30
MOV EDI,ESI     edi = esi
SHR EDI,1E      edi >>>= 0x1E
XOR EDI,ESI     edi ^= esi
IMUL EDI,EDI,6C078965  edi *= 0x6C078965
LEA ESI,DWORD PTR DS:[EDI+EAX]      esi = edi+eax 
MOV EDI,ESI  edi = esi     
SHR EDI,1E   edi >>>= 0x1E
XOR EDI,ESI  edi ^= esi
IMUL EDI,EDI,6C078965   edi *= 6C078965
MOV DWORD PTR DS:[EDX-4],ESI   second = esi       







LEA ESI,DWORD PTR DS:[EDI+EAX+6]	esi = edi+eax+6;
MOV DWORD PTR DS:[EDX+14],ESI   	        ;  write! eight value



eax+634




0018F7B8  D6 E2 6E C6 97 7C F6 B0 58 E5 FD FD 77 31 66 BE  ÖânÆ—|ö°Xåýýw1f¾
0018F7C8  BA 21 FC 84 2A C7 8C F1 C0 85 3E 61 B9 0F 86 E7  º!ü„*ÇŒñÀ…>a¹†ç
0018F7D8  F7 BF 64 FC DA 50 25 AE CF 7E E4 02 43 D0 AB 37  ÷¿düÚP%®Ï~äCÐ«7


D6 E2 6E C6 97 7C F6 B0 58 E5 FD FD 77 31 66 BE


 0xB3ECF0A1
 
 
 
 
MOV ECX,DWORD PTR DS:[EAX+4]    ecx = arr[1]
MOV EDI,DWORD PTR DS:[EAX]      edi = arr[0]
MOV EBX,DWORD PTR DS:[EAX]      ebx = arr[0]
XOR EDI,ECX                     edi ^= ecx
AND EDI,7FFFFFFE                edi ^= 0x7FFFFFFE
XOR EDI,EBX                     edi ^= ebx
AND CL,1			            ecx ^= 0xFFFFFF01
SHR EDI,1						edi >>>= 1
NEG CL							ecx = -((byte)(ecx & 0xFF)) & ecx
SBB ECX,ECX                       if cl, was not zero, add an extra one. 
AND ECX,9908B0DF                ecx &= 0x9908B0DF
XOR EDI,ECX                     edi ^= ecx
XOR EDI,DWORD PTR DS:[EAX+634]  edi ^= arr[397]        ;  edi contains the computed dword. wait, is this not simply the same array?
MOV DWORD PTR DS:[EAX],EDI      arr[0] = edi        ;  set a dword in the array.
ADD EAX,4                       iterate further
DEC EDX                         increase i of for loop.
JNZ SHORT SuperMar.0048B440



MOV ECX,DWORD PTR DS:[EAX+4]     
MOV EDI,DWORD PTR DS:[EAX]	    
MOV EBX,DWORD PTR DS:[EAX]      
XOR EDI,ECX                    
AND EDI,7FFFFFFE           
XOR EDI,EBX
MOV EBX,DWORD PTR DS:[EAX-38C]
AND CL,1
SHR EDI,1
NEG CL
SBB ECX,ECX
AND ECX,9908B0DF
XOR EDI,ECX
XOR EDI,EBX
MOV DWORD PTR DS:[EAX],EDI               ;  here!
ADD EAX,4
DEC EDX                                  ;  end loop





XOR EDX,ECX							edx ^= ecx
AND EDX,7FFFFFFE					edx &= 7FFFFFFE
XOR EDX,EBX							edx ^= ebx
AND CL,1							
SHR EDX,1
NEG CL
POP EDI
POP ESI
POP EBX
SBB ECX,ECX
AND ECX,9908B0DF
XOR EDX,ECX
XOR EDX,DWORD PTR DS:[EAX-38C]
MOV DWORD PTR DS:[EAX],EDX               ;  here!





	/*	ecx = arr[0];
		edx = arr[eax];
		ebx = arr[eax];

		edx ^= ecx;
		edx &= 0x7FFFFFFE;	
		edx ^= ebx;


		ecx &= 0xFFFFFF01; // AND CL,1
		edx >>>= 1;

		cl = getCL(ecx);
		cf = (char)(cl == 0 ? 0 : 1);
		ecx = setCL(ecx, (char)(-cl)); // NEG CL
		
		
		ecx = ecx - (ecx+cl); // SBB ECX, ECX


		ecx &= 0x9908B0DF;
		
		edx ^= ecx;
		
		edx ^= arr[eax-227];
		arr[eax] = edx;*/




		
cliff_grass_die.png


02247C50  B7 56 6F B3 74 40 A7 38 B5 73 AE 19 F8 28 8A EC  ·Vo³t@§8µs®ø(Šì

2E 81 00 00               



2e 81 00 00 
27 95 96 35 shouldb first elemtns. 



the last element is the seed. 


640 = 0x280 is the width of the image. 

480 = 0x1E0 is the height. 

0x5BB0 is the size of the file.                    


char.png
02F03C10  9F DB 41 37 3F DC 3A D1 F7 A9 72 7B CB 2C 04 81  ŸÛA7?Ü:Ñ÷©r{Ë,
at 01cb6a9e

CA 87 CC 01


[98, 51, 48, 101, 57, 98,


9C 06 CC 01 is the index to the file. it is added to some other number. 


b30e9b06 here is the first. 

fae452e8 1 value.
100397a4 3 value. 
f521a50b 2 value. 
9f6b3da5 5 value. 
0f8eedef 4 value. 
212f5c84 7 value. 
6074144f 6 value. 
6b690a63 9 value. 
928db513 8 value. 
877154cb 10 value
ac0edc8e 9 value. 
dc4e31d2 12 value.
f02599fc 11 value.
4734d347 14 value.
3594928f 13 value.


this one is computed beforehand:
0018F20C  F7 C2 90 1F DF 43 54 C6 B8 50 DC B0 11 DB 4F 25  ÷ÂßCTÆ¸PÜ°ÛO%
0018F21C  7E 0C 8C C2 00 83 D0 04 68 E4 63 DA E8 F9 55 9E  ~.ŒÂ.ƒÐhäcÚèùUž
0018F22C  C3 63 D1 24 CC 24 0D 1C 85 F9 FE 2C C6 17 C2 2D  ÃcÑ$Ì$.…ùþ,ÆÂ-


this one is computed in the function:
it is set in the last iteration if the loop. 
0018E800  F1 8F 53 DB 27 57 BA EC 53 54 45 44 93 BC B3 EA  ñSÛ'WºìSTED“¼³ê
0018E810  71 E1 02 4D A4 BA 9A 9A E7 2F 10 86 9B 62 D9 82  qáM¤ºššç/†›bÙ‚
0018E820  50 51 BC 6D 97 E5 5B 4F 09 E3 0F 7F 05 3D AF 59  PQ¼m—å[O.ã=¯Y

to compute this you use this array:

edi+edx*8+40 = 
0048EC55  0F 6F 44 D7 40 90 0F 6F 0C CB 0F 7F C2 0F 7F C3  oD×@o.ËÂÃ





[eax+10] = 1F90C2F7   1F 90 C2 F7
[ebp-2c8] = DB538FF1    DB 53 8F F1
are summed to produce the hash
FA E4 52 E8




E8 52 E4 FA

F1 8F 53 DB 

0018e828


edi+edx*8+8


png

gnp


0018F264  08 C9 BC F3 67 E6 09 6A 3B A7 CA 84 85 AE 67 BB  É¼ógæ.j;§Ê„…®g»
0018F274  2B F8 94 FE 72 F3 6E 3C F1 36 1D 5F 3A F5 4F A5  +ø”þrón<ñ6_:õO¥
0018F284  D1 82 E6 AD 7F 52 0E 51 1F 6C 3E 2B 8C 68 05 9B  Ñ‚æ­RQl>+Œh›
0018F294  6B BD 41 FB AB D9 83 1F 79 21 7E 13 19 CD E0 5B  k½Aû«Ùƒy!~Íà[

